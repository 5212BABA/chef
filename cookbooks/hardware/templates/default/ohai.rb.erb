Ohai.plugin(:Hardware) do
  provides "hardware"

  def read_sysctl_link(file)
    File.basename(File.readlink(file))
  rescue Errno::ENOENT
  end

  def read_sysctl_file(file)
    IO.read(file).strip
  rescue Errno::ENOENT, Errno::EINVAL
  end

  def parse_memory_size(size)
    if size =~ /^(\d+(?:\.\d+)?)\s*TB/i
      Regexp.last_match(1).to_f * 2**30
    elsif size =~ /^(\d+(?:\.\d+)?)\s*GB/i
      Regexp.last_match(1).to_f * 2**20
    elsif size =~ /^(\d+(?:\.\d+)?)\s*MB/i
      Regexp.last_match(1).to_f * 2**10
    end
  end

  def format_disk_size(kb)
    if kb == 0
      ""
    else
      kblog10 = Math.log10(kb).floor

      kb = kb.to_f * 2 / 10**kblog10
      kb = kb.round.to_f / 2

      if kblog10 >= 9
        format "%gTB", kb * 10**(kblog10 - 9)
      elsif kblog10 >= 6
        format "%dGB", kb * 10**(kblog10 - 6)
      else
        format "%dMB", kb * 10**(kblog10 - 3)
      end
    end
  end

  def memory_to_disk_size(size)
    format_disk_size(parse_memory_size(size))
  end

  def find_sas_device(address)
    file = Dir.glob("/sys/class/scsi_generic/sg*/device/sas_address").find do |file|
      read_sysctl_file(file) == "0x#{address}"
    end

    if file
      dir = File.dirname(file)
      device = Dir.glob("#{dir}/block/*").first ||
               Dir.glob("#{dir}/scsi_generic/*").first

      "/dev/#{File.basename(device)}"
    end
  end

  def pci_devices
    device = nil

    IO.popen(["lspci", "-Dkvmm"]).each_with_object(Mash.new) do |line, devices|
      if line =~ /^Slot:\s+((\h{4}):(\h{2}):(\h{2}).(\h))\s*$/
        device = {
          :slot => Regexp.last_match(1),
          :domain => Regexp.last_match(2),
          :bus => Regexp.last_match(3),
          :device => Regexp.last_match(4),
          :function => Regexp.last_match(5)
        }
      elsif device && line =~ /^([A-Z]+):\s+(.*)\s*$/i
        case Regexp.last_match(1)
        when "Class" then device[:class_name] = Regexp.last_match(2)
        when "Vendor" then device[:vendor_name] = Regexp.last_match(2)
        when "Device" then device[:device_name] = Regexp.last_match(2)
        when "SVendor" then device[:subsystem_vendor_name] = Regexp.last_match(2)
        when "SDevice" then device[:subsystem_device_name] = Regexp.last_match(2)
        when "PhySlot" then device[:physical_slot] = Regexp.last_match(2)
        when "Rev" then device[:revision] = Regexp.last_match(2)
        when "ProgIf" then device[:programming_interface] = Regexp.last_match(2)
        when "Driver" then device[:driver] = Regexp.last_match(2)
        when "Module" then device[:modules] = Array(device[:modules]) << Regexp.last_match(2)
        end
      elsif device && line =~ /^\s*$/
        devices[device[:slot]] = device
        device = nil
      end
    end
  end

  def network_devices
    Dir.glob("/sys/class/net/*").each_with_object(Mash.new) do |device, devices|
      name = File.basename(device)

      devices[name] = {
        :device => read_sysctl_link("#{device}/device"),
        :duplex => read_sysctl_file("#{device}/duplex"),
        :speed => read_sysctl_file("#{device}/speed")
      }.delete_if { |_, v| v.nil? }
    end
  end

  def memory_devices
    device = nil

    IO.popen(["dmidecode", "-t", "memory"]).each_with_object([]) do |line, devices|
      if line =~ /^Memory Device\s*$/
        device = {}
      elsif device && line =~ /^\s+([A-Z ]+):\s+(.*)\s*$/i
        device[Regexp.last_match(1).tr(" ", "_").downcase.to_sym] = Regexp.last_match(2).strip
      elsif device && line =~ /^\s*$/
        devices << device
        device = nil
      end
    end
  end

  def disk_devices
    disk = Mash.new

    disk[:controllers] = []
    disk[:arrays] = []
    disk[:disks] = []

    find_direct_disks(disk)

    find_hp_disks(disk) if File.exist?("/usr/sbin/hpssacli")
    find_megaraid_disks(disk) if File.exist?("/usr/sbin/megacli")
    find_mpt_disks(disk) if File.exist?("/usr/sbin/sas2ircu")
    # aacraid
    find_areca_disks(disk) if File.exist?("/opt/areca/x86_64/cli64")

    find_md_arrays(disk)

    disk
  end

  def find_direct_disks(devices)
    Dir.glob("/sys/class/scsi_host/host*") do |host|
      driver = read_sysctl_file("#{host}/proc_name")

      if driver == "ahci" || driver == "mptsas"
        bus = host.sub("/sys/class/scsi_host/host", "")

        Dir.glob("/sys/bus/scsi/devices/#{bus}:0:*").each do |device|
          next unless File.exist?("#{device}/scsi_disk")

          block = Dir.glob("#{device}/block/*").first
          vendor = read_sysctl_file("#{device}/vendor")
          model = read_sysctl_file("#{device}/model")
          size = read_sysctl_file("#{block}/size").to_i * 512

          if vendor == "ATA" && model =~ /^(\S+)\s+(.*)$/
            vendor = Regexp.last_match(1)
            model = Regexp.last_match(2)
          end

          devices[:disks] << {
            :id => devices[:disks].count,
            :device => "/dev/#{File.basename(block)}",
            :vendor => vendor,
            :model => model,
            :firmware_version => read_sysctl_file("#{device}/rev"),
            :size => format_disk_size(size),
            :arrays => []
          }
        end
      end
    end
  end

  def find_md_arrays(devices)
    array = nil

    File.new("/proc/mdstat", "r").each do |line|
      if line =~ /^(md\d+) : active raid(\d+)((?: [a-z]+\d+\[\d+\](?:\([A-Z]\))*)+)$/
        array = {
          :id => devices[:arrays].count,
          :device => "/dev/#{Regexp.last_match(1)}",
          :raid_level => Regexp.last_match(2),
          :disks => []
        }

        Regexp.last_match(3).scan(/ ([a-z]+)\d+\[\d+\](?:\([A-Z]\))*/).flatten.each do |device|
          if disk = devices[:disks].find { |d| d[:device] == "/dev/#{device}" }
            disk[:arrays] << array[:id]
            array[:disks] << disk[:id]
          end
        end

        devices[:arrays] << array
      elsif line =~ /^\s+(\d+) blocks/
        array[:size] = format_disk_size(Regexp.last_match(1).to_i)
      end
    end
  end

  def find_hp_disks(devices)
    controllers = []
    disks = []

    controller = nil
    array = nil
    disk = nil

    IO.popen(%w(hpssacli controller all show config detail)).each do |line|
      if line =~ /^Smart Array (\S+) /
        controller = {
          :id => devices[:controllers].count,
          :model => Regexp.last_match(1),
          :arrays => [],
          :disks => []
        }

        devices[:controllers] << controller

        controllers << controller

        array = nil
        disk = nil
      elsif controller && line =~ /^   (\S.*):\s+(.*)$/
        case Regexp.last_match(1)
        when "Serial Number" then controller[:serial_number] = Regexp.last_match(2)
        when "Hardware Revision" then controller[:hardware_version] = Regexp.last_match(2)
        when "Firmware Version" then controller[:firmware_version] = Regexp.last_match(2)
        when "PCI Address (Domain:Bus:Device.Function)" then controller[:pci_slot] = Regexp.last_match(2)
        end
      elsif controller && line =~ /^      Logical Drive: (\d+)$/
        array = {
          :id => devices[:arrays].count,
          :controller => controller[:id],
          :number => Regexp.last_match(1),
          :disks => []
        }

        devices[:arrays] << array
        controller[:arrays] << array[:id]

        disk = nil
      elsif controller && line =~ /^      physicaldrive (\S+) /
        disks << Regexp.last_match(1)
      elsif array && line =~ /^      physicaldrive (\S+)$/
        disk = {
          :id => devices[:disks].count,
          :controller => controller[:id],
          :arrays => [array[:id]],
          :location => Regexp.last_match(1),
          :smart_device => "cciss,#{disks.find_index(Regexp.last_match(1))}"
        }

        devices[:disks] << disk
        controller[:disks] << disk[:id]
        array[:disks] << disk[:id]
      elsif disk && line =~ /^         (\S[^:]+):\s+(.*)$/
        case Regexp.last_match(1)
        when "Interface Type" then disk[:interface] = Regexp.last_match(2)
        when "Size" then disk[:size] = Regexp.last_match(2)
        when "Rotational Speed" then disk[:rpm] = Regexp.last_match(2)
        when "Firmware Revision" then disk[:firmware_version] = Regexp.last_match(2)
        when "Serial Number" then disk[:serial_number] = Regexp.last_match(2)
        when "Model" then disk[:vendor], disk[:model] = Regexp.last_match(2).squeeze(" ").strip.sub(/^ATA /, "").split
        end
      elsif array && line =~ /^         (\S[^:]+):\s+(.*)$/
        case Regexp.last_match(1)
        when "Size" then array[:size] = Regexp.last_match(2)
        when "Fault Tolerance" then array[:raid_level] = Regexp.last_match(2)
        when "Disk Name" then array[:device] = Regexp.last_match(2).strip
        when "Mount Points" then array[:mount_point] = Regexp.last_match(2).split.first
        when "Unique Identifier" then array[:wwn] = Regexp.last_match(2)
        end
      end
    end

    controllers.each do |controller|
      if device = Dir.glob("/sys/bus/pci/devices/#{controller[:pci_slot]}/cciss*").first
        controller[:device] = File.basename(device).sub(/^cciss(\d+)$/, "/dev/cciss/c\\1d0")
      elsif device = Dir.glob("/sys/bus/pci/devices/#{controller[:pci_slot]}/host*/target0:0:0/0:0:0:0/scsi_generic/sg*").first
        controller[:device] = "/dev/#{File.basename(device)}"
      end
    end
  end

  def find_megaraid_disks(devices)
    controllers = []
    arrays = []

    controller = nil
    array = nil
    disk = nil

    IO.popen(%w(megacli -AdpGetPciInfo -aAll -NoLog)).each do |line|
      if line =~ /^PCI information for Controller (\d+)$/
        controller = {
          :id => devices[:controllers].count,
          :arrays => [],
          :disks => []
        }

        devices[:controllers] << controller

        controllers << controller
      elsif line =~ /^Bus Number\s+:\s+(\d+)$/
        controller[:pci_slot] = format "0000:%02x", Integer("0x#{Regexp.last_match(1)}")
      elsif line =~ /^Device Number\s+:\s+(\d+)$/
        controller[:pci_slot] = format "%s:%02x", controller[:pci_slot], Integer("0x#{Regexp.last_match(1)}")
      elsif line =~ /^Function Number\s+:\s+(\d+)$/
        controller[:pci_slot] = format "%s.%01x", controller[:pci_slot], Integer("0x#{Regexp.last_match(1)}")
      end
    end

    IO.popen(%w(megacli -AdpAllInfo -aAll -NoLog)).each do |line|
      if line =~ /^Adapter #(\d+)$/
        controller = controllers[Regexp.last_match(1).to_i]
      elsif line =~ /^(\S.*\S)\s*:\s+(\S.*)$/
        case Regexp.last_match(1)
        when "Product Name" then controller[:model] = Regexp.last_match(2)
        when "Serial No" then controller[:serial_number] = Regexp.last_match(2)
        when "FW Package Build" then controller[:firmware_version] = Regexp.last_match(2)
        end
      end
    end

    IO.popen(%w(megacli -LdPdInfo -aAll -NoLog)).each do |line|
      if line =~ /^Adapter #(\d+)$/
        controller = controllers[Regexp.last_match(1).to_i]
      elsif controller && line =~ /^Virtual Drive: (\d+) \(Target Id: (\d+)\)$/
        pci_slot = controller[:pci_slot]
        target = Regexp.last_match(2)
        device = Dir.glob("/sys/bus/pci/devices/#{pci_slot}/host*/target*:2:#{target}/*:2:#{target}:0/block/*").first

        array = {
          :id => devices[:arrays].count,
          :controller => controller[:id],
          :number => Regexp.last_match(1),
          :device => "/dev/#{File.basename(device)}",
          :disks => []
        }

        devices[:arrays] << array
        controller[:arrays] << array[:id]

        arrays << array

        disk = nil
      elsif array && line =~ /^PD: (\d+) Information$/
        disk = {
          :id => devices[:disks].count,
          :controller => controller[:id],
          :arrays => [array[:id]]
        }

        devices[:disks] << disk
        controller[:disks] << disk[:id]
        array[:disks] << disk[:id]
      elsif disk && line =~ /^(\S.*\S)\s*:\s+(\S.*)$/
        case Regexp.last_match(1)
        when "Device Id" then disk[:smart_devlce] = "megaraid,#{Regexp.last_match(2)}"
        when "WWN" then disk[:wwn] = Regexp.last_match(2)
        when "PD Type" then disk[:interface] = Regexp.last_match(2)
        when "Raw Size" then disk[:size] = memory_to_disk_size(Regexp.last_match(2).sub(/\s*\[.*\]$/, ""))
        when "Inquiry Data" then disk[:vendor], disk[:model], disk[:serial] = Regexp.last_match(2).split
        end
      elsif array && line =~ /^(\S.*\S)\s*:\s+(\S.*)$/
        case Regexp.last_match(1)
        when "RAID Level" then array[:raid_level] = Regexp.last_match(2).scan(/Primary-(\d+)/).first.first
        when "Size" then array[:size] = Regexp.last_match(2)
        end
      end
    end

    IO.popen(%w(megacli -PDList -aAll -NoLog)).each do |line|
      if line =~ /^Adapter #(\d+)$/
        controller = controllers[Regexp.last_match(1).to_i]
      elsif controller && line =~ /^Enclosure Device ID: \d+$/
        disk = {
          :controller => controller[:id]
        }
      elsif disk && line =~ /^WWN:\s+(\S+)$/
        unless devices[:disks].find { |d| d[:wwn] == Regexp.last_match(1) }
          disk[:id] = devices[:disks].count
          disk[:wwn] = Regexp.last_match(1)

          devices[:disks] << disk
        end
      elsif disk && line =~ /^(\S.*\S)\s*:\s+(\S.*)$/
        case Regexp.last_match(1)
        when "Device Id" then disk[:smart_devlce] = "megaraid,#{Regexp.last_match(2)}"
        when "WWN" then disk[:wwn] = Regexp.last_match(2)
        when "PD Type" then disk[:interface] = Regexp.last_match(2)
        when "Raw Size" then disk[:size] = memory_to_disk_size(Regexp.last_match(2).sub(/\s*\[.*\]$/, ""))
        when "Inquiry Data" then disk[:vendor], disk[:model], disk[:serial] = Regexp.last_match(2).split
        end
      end
    end

    controllers.each do |controller|
      if device = Dir.glob("/sys/bus/pci/devices/#{controller[:pci_slot]}/host*/target*:2:0/*/scsi_generic/sg*").first
        controller[:device] = "/dev/#{File.basename(device)}"
      end
    end
  end

  def find_mpt_disks(devices)
    controllers = []

    IO.popen(%w(sas2ircu list)).each do |line|
      next unless line =~ /^\s+(\d+)\s+(\S+)\s+\h+h\s+\h+h\s+(\S+)\s+\h+h\s+\h+h\s*$/
      controllers[Regexp.last_match(1).to_i] = {
        :id => devices[:controllers].count,
        :model => Regexp.last_match(2),
        :pci_slot => Regexp.last_match(3).sub(/^(\h{2})h:(\h{2})h:(\h{2})h:0(\h)h$/, "00\\1:\\2:\\3.\\4"),
        :arrays => [],
        :disks => []
      }

      devices[:controllers] << controllers[Regexp.last_match(1).to_i]
    end

    controllers.each_with_index do |controller, index|
      arrays = []
      disks = []

      array = nil
      disk = nil

      IO.popen(["sas2ircu", index.to_s, "display"]).each do |line|
        if line =~ /^IR volume (\d+)$/
          array = {
            :id => devices[:arrays].count,
            :controller => controller[:id],
            :number => Regexp.last_match(1),
            :disks => []
          }

          devices[:arrays] << array
          controller[:arrays] << array[:id]

          arrays << array
        elsif line =~ /^Device is a Hard disk$/
          disk = {
            :id => devices[:disks].count,
            :controller => controller[:id],
            :arrays => []
          }

          devices[:disks] << disk
          controller[:disks] << disk[:id]

          disks << disk
        elsif disk && line =~ /^  (\S.*\S)\s+:\s+(.*\S)\s*$/
          case Regexp.last_match(1)
          when "Enclosure #" then disk[:location] = Regexp.last_match(2)
          when "Slot #" then disk[:location] = "#{disk[:location]}:#{Regexp.last_match(2)}"
          when "SAS Address" then disk[:device] = find_sas_device(Regexp.last_match(2).tr("-", ""))
          when "Size (in MB)/(in sectors)" then disk[:size] = memory_to_disk_size("#{Regexp.last_match(2).split('/').first} MB")
          when "Manufacturer" then disk[:vendor] = Regexp.last_match(2)
          when "Model Number" then disk[:model] = Regexp.last_match(2)
          when "Firmware Revision" then disk[:firmware_version] = Regexp.last_match(2)
          when "Serial Number" then disk[:serial_number] = Regexp.last_match(2)
          when "Protocol" then disk[:interface] = Regexp.last_match(2)
          end
        elsif array && line =~ /^  PHY\[\d+\] Enclosure#\/Slot#\s+:\s+(\d+:\d+)\s*$/
          array[:disks] << Regexp.last_match(1)
        elsif array && line =~ /^  (\S.*\S)\s+:\s+(.*\S)\s*$/
          case Regexp.last_match(1)
          when "Volume wwid" then array[:device] = find_sas_device(Regexp.last_match(2))
          when "RAID level" then array[:raid_level] = Regexp.last_match(2).sub(/^RAID/, "")
          when "Size (in MB)" then array[:size] = "#{Regexp.last_match(2)} MB"
          end
        elsif line =~ /^  (\S.*\S)\s+:\s+(.*\S)\s*$/
          case Regexp.last_match(1)
          when "BIOS version" then controller[:bios_version] = Regexp.last_match(2)
          when "Firmware version" then controller[:firmware_version] = Regexp.last_match(2)
          end
        end
      end

      arrays.each do |array|
        array[:disks].map! do |location|
          disk = disks.find { |disk| disk[:location] == location }

          disk[:arrays] << array[:id]
          disk[:id]
        end
      end
    end
  end

  def find_areca_disks(devices)
    controller = {
      :id => devices[:controllers].count,
      :arrays => [],
      :disks => []
    }

    devices[:controllers] << controller

    IO.popen(%w(/opt/areca/x86_64/cli64 sys info)).each do |line|
      next unless line =~ /^(\S.*\S)\s+:\s+(.*\S)\s*$/

      case Regexp.last_match(1)
      when "Firmware Version" then controller[:firmware_version] = Regexp.last_match(2)
      when "BOOT ROM Version" then controller[:bios_version] = Regexp.last_match(2)
      when "Serial Number" then controller[:serial_number] = Regexp.last_match(2)
      when "Controller Name" then controller[:model] = Regexp.last_match(2)
      end
    end

    path = Dir.glob("/sys/bus/pci/devices/*/host*/scsi_host/host*/host_fw_model").find do |file|
      read_sysctl_file(file) == controller[:model]
    end

    controller[:pci_slot] = File.basename(File.expand_path("#{path}/../../../.."))
    controller[:device] = File.basename(Dir.glob(File.expand_path("#{path}/../../../target0:0:16/0:0:16:0/scsi_generic/*")).first)

    arrays = []

    IO.popen(%w(/opt/areca/x86_64/cli64 vsf info)).each do |line|
      next unless line =~ /^\s+(\d+)\s+/
      array = {
        :id => devices[:arrays].count,
        :number => Regexp.last_match(1),
        :controller => controller[:id],
        :disks => []
      }

      devices[:arrays] << array
      controller[:arrays] << array[:id]

      arrays << array
    end

    arrays.each do |array|
      IO.popen(["/opt/areca/x86_64/cli64", "vsf", "info", "vol=#{array[:number]}"]).each do |line|
        next unless line =~ /^(\S.*\S)\s+:\s+(.*\S)\s*$/

        case Regexp.last_match(1)
        when "Volume Set Name" then array[:volume_set] = Regexp.last_match(2)
        when "Raid Set Name" then array[:raid_set] = Regexp.last_match(2)
        when "Volume Capacity" then array[:size] = format_disk_size(Regexp.last_match(2).to_f * 1000 * 1000)
        when "Raid Level" then array[:raid_level] = Regexp.last_match(2).sub(/^Raid/, "")
        end
      end
    end

    disks = []

    IO.popen(%w(/opt/areca/x86_64/cli64 disk info)).each do |line|
      next unless line =~ /^\s+(\d+)\s+.*\s+\d+\.\d+GB\s+(\S.*\S)\s*$/
      next if Regexp.last_match(2) == "N.A."

      disk = {
        :id => devices[:disks].count,
        :number => Regexp.last_match(1),
        :controller => controller[:id],
        :arrays => []
      }

      devices[:disks] << disk
      controller[:disks] << disk[:id]

      if array = arrays.find { |array| array[:raid_set] == Regexp.last_match(2) }
        disk[:arrays] << array[:id]
        array[:disks] << disk[:id]
      end

      disks << disk
    end

    disks.each do |disk|
      IO.popen(["/opt/areca/x86_64/cli64", "disk", "info", "drv=#{disk[:number]}"]).each do |line|
        if line =~ /^IDE Channel\s+:\s+(\d+)\s*$/i
          disk[:smart_device] = "areca,#{Regexp.last_match(1)}"
        elsif line =~ /^Device Location\s+:\s+Enclosure#(\d+) Slot#?\s*0*(\d+)\s*$/i
          disk[:smart_device] = "areca,#{Regexp.last_match(2)}/#{Regexp.last_match(1)}"
        elsif line =~ /^(\S.*\S)\s+:\s+(.*\S)\s*$/
          case Regexp.last_match(1)
          when "Model Name" then disk[:vendor], disk[:model] = Regexp.last_match(2).split
          when "Serial Number" then disk[:serial_number] = Regexp.last_match(2)
          when "Disk Capacity" then disk[:size] = format_disk_size(Regexp.last_match(2).to_f * 1000 * 1000)
          end
        end
      end
    end
  end

  collect_data(:default) do
    hardware Mash.new

    hardware[:pci] = pci_devices
    hardware[:network] = network_devices
    hardware[:memory] = memory_devices
    hardware[:disk] = disk_devices
  end
end
