Ohai.plugin(:Hardware) do
  provides "hardware"

  def read_sysctl_link(file)
    File.basename(File.readlink(file))
  rescue Errno::ENOENT
  end

  def read_sysctl_file(file)
    IO.read(file).strip
  rescue Errno::ENOENT, Errno::EINVAL
  end

  def pci_devices
    device = nil

    IO.popen(["lspci", "-Dkvmm"]).each_with_object(Mash.new) do |line, devices|
      if line =~ /^Slot:\s+((\h{4}):(\h{2}):(\h{2}).(\h))\s*$/
        device = {
          :slot => Regexp.last_match(1),
          :domain => Regexp.last_match(2),
          :bus => Regexp.last_match(3),
          :device => Regexp.last_match(4),
          :function => Regexp.last_match(5)
        }
      elsif device && line =~ /^([A-Z]+):\s+(.*)\s*$/i
        case Regexp.last_match(1)
        when "Class" then device[:class_name] = Regexp.last_match(2)
        when "Vendor" then device[:vendor_name] = Regexp.last_match(2)
        when "Device" then device[:device_name] = Regexp.last_match(2)
        when "SVendor" then device[:subsystem_vendor_name] = Regexp.last_match(2)
        when "SDevice" then device[:subsystem_device_name] = Regexp.last_match(2)
        when "PhySlot" then device[:physical_slot] = Regexp.last_match(2)
        when "Rev" then device[:revision] = Regexp.last_match(2)
        when "ProgIf" then device[:programming_interface] = Regexp.last_match(2)
        when "Driver" then device[:driver] = Regexp.last_match(2)
        when "Module" then device[:modules] = Array(device[:modules]) << Regexp.last_match(2)
        end
      elsif device && line =~ /^\s*$/
        devices[device[:slot]] = device
        device = nil
      end
    end
  end

  def network_devices
    Dir.glob("/sys/class/net/*").each_with_object(Mash.new) do |device, devices|
      name = File.basename(device)

      devices[name] = {
        :device => read_sysctl_link("#{device}/device"),
        :duplex => read_sysctl_file("#{device}/duplex"),
        :speed => read_sysctl_file("#{device}/speed")
      }.delete_if { |_, v| v.nil? }
    end
  end

  def memory_devices
    device = nil

    IO.popen(["dmidecode", "-t", "memory"]).each_with_object([]) do |line, devices|
      if line =~ /^Memory Device\s*$/
        device = {}
      elsif device && line =~ /^\s+([A-Z ]+):\s+(.*)\s*$/i
        device[Regexp.last_match(1).tr(" ", "_").downcase.to_sym] = Regexp.last_match(2).strip
      elsif device && line =~ /^\s*$/
        devices << device
        device = nil
      end
    end
  end

  def disk_devices
    disk = Mash.new

    disk[:controllers] = []
    disk[:arrays] = []
    disk[:disks] = []

    find_hp_disks(disk) if File.exist?("/usr/sbin/hpssacli")
    find_megaraid_disks(disk) if File.exist?("/usr/sbin/megacli")

    disk
  end

  def find_hp_disks(devices)
    controllers = []
    disks = []

    controller = nil
    array = nil
    disk = nil

    IO.popen(%w(hpssacli controller all show config detail)).each do |line|
      if line =~ /^Smart Array (\S+) /
        controller = {
          :id => devices[:controllers].count,
          :model => Regexp.last_match(1),
          :arrays => [],
          :disks => []
        }

        devices[:controllers] << controller

        controllers << controller

        array = nil
        disk = nil
      elsif controller && line =~ /^   (\S.*):\s+(.*)$/
        case Regexp.last_match(1)
        when "Serial Number" then controller[:serial_number] = Regexp.last_match(2)
        when "Hardware Revision" then controller[:hardware_version] = Regexp.last_match(2)
        when "Firmware Version" then controller[:firmware_version] = Regexp.last_match(2)
        when "PCI Address (Domain:Bus:Device.Function)" then controller[:pci_slot] = Regexp.last_match(2)
        end
      elsif controller && line =~ /^      Logical Drive: (\d+)$/
        array = {
          :id => devices[:arrays].count,
          :controller => controller[:id],
          :number => Regexp.last_match(1),
          :disks => []
        }

        devices[:arrays] << array
        controller[:arrays] << array[:id]

        disk = nil
      elsif controller && line =~ /^      physicaldrive (\S+) /
        disks << Regexp.last_match(1)
      elsif array && line =~ /^      physicaldrive (\S+)$/
        disk = {
          :id => devices[:disks].count,
          :controller => controller[:id],
          :array => array[:id],
          :location => Regexp.last_match(1),
          :smart_device => "cciss,#{disks.find_index(Regexp.last_match(1))}"
        }

        devices[:disks] << disk
        controller[:disks] << disk[:id]
        array[:disks] << disk[:id]
      elsif disk && line =~ /^         (\S[^:]+):\s+(.*)$/
        case Regexp.last_match(1)
        when "Interface Type" then disk[:interface] = Regexp.last_match(2)
        when "Size" then disk[:size] = Regexp.last_match(2)
        when "Rotational Speed" then disk[:rpm] = Regexp.last_match(2)
        when "Firmware Revision" then disk[:firmware_version] = Regexp.last_match(2)
        when "Serial Number" then disk[:serial_number] = Regexp.last_match(2)
        when "Model" then disk[:vendor], disk[:model] = Regexp.last_match(2).squeeze(" ").strip.sub(/^ATA /, "").split
        end
      elsif array && line =~ /^         (\S[^:]+):\s+(.*)$/
        case Regexp.last_match(1)
        when "Size" then array[:size] = Regexp.last_match(2)
        when "Fault Tolerance" then array[:raid_level] = Regexp.last_match(2)
        when "Disk Name" then array[:device] = Regexp.last_match(2).strip
        when "Mount Points" then array[:mount_point] = Regexp.last_match(2).split.first
        when "Unique Identifier" then array[:wwn] = Regexp.last_match(2)
        end
      end
    end

    controllers.each do |controller|
      if device = Dir.glob("/sys/bus/pci/devices/#{controller[:pci_slot]}/cciss*").first
        controller[:device] = File.basename(device).sub(/^cciss(\d+)$/, "/dev/cciss/c\\1d0")
      elsif device = Dir.glob("/sys/bus/pci/devices/#{controller[:pci_slot]}/host*/target0:0:0/0:0:0:0/scsi_generic/sg*").first
        controller[:device] = "/dev/#{File.basename(device)}"
      end
    end
  end

  def find_megaraid_disks(devices)
    controllers = []
    arrays = []

    controller = nil
    array = nil
    disk = nil

    IO.popen(%w(megacli -AdpGetPciInfo -aAll -NoLog)).each do |line|
      if line =~ /^PCI information for Controller (\d+)$/
        controller = {
          :id => devices[:controllers].count,
          :arrays => [],
          :disks => []
        }

        devices[:controllers] << controller

        controllers << controller
      elsif line =~ /^Bus Number\s+:\s+(\d+)$/
        controller[:pci_slot] = sprintf "0000:%02x", Integer("0x#{Regexp.last_match(1)}")
      elsif line =~ /^Device Number\s+:\s+(\d+)$/
        controller[:pci_slot] = sprintf "%s:%02x", controller[:pci_slot], Integer("0x#{Regexp.last_match(1)}")
      elsif line =~ /^Function Number\s+:\s+(\d+)$/
        controller[:pci_slot] = sprintf "%s.%01x", controller[:pci_slot], Integer("0x#{Regexp.last_match(1)}")
      end
    end

    IO.popen(%w(megacli -AdpAllInfo -aAll -NoLog)).each do |line|
      if line =~ /^Adapter #(\d+)$/
        controller = controllers[Regexp.last_match(1).to_i]
      elsif line =~ /^(\S.*\S)\s*:\s+(\S.*)$/
        case Regexp.last_match(1)
        when "Product Name" then controller[:model] = Regexp.last_match(2)
        when "Serial No" then controller[:serial_number] = Regexp.last_match(2)
        when "FW Package Build" then controller[:firmware_version] = Regexp.last_match(2)
        end
      end
    end

    IO.popen(%w(megacli -LdPdInfo -aAll -NoLog)).each do |line|
      if line =~ /^Adapter #(\d+)$/
        controller = controllers[Regexp.last_match(1).to_i]
      elsif controller && line =~ /^Virtual Drive: (\d+) \(Target Id: (\d+)\)$/
        array = {
          :id => devices[:arrays].count,
          :controller => controller[:id],
          :number => Regexp.last_match(1),
          :disks => []
        }

        devices[:arrays] << array
        controller[:arrays] << array[:id]

        arrays << array

        disk = nil
      elsif array && line =~ /^PD: (\d+) Information$/
        disk = {
          :id => devices[:disks].count,
          :controller => controller[:id],
          :array => array[:id]
        }

        devices[:disks] << disk
        controller[:disks] << disk[:id]
        array[:disks] << disk[:id]
      elsif disk && line =~ /^(\S.*\S)\s*:\s+(\S.*)$/
        case Regexp.last_match(1)
        when "Device Id" then disk[:smart_devlce] = "megaraid,#{Regexp.last_match(2)}"
        when "WWN" then disk[:wwn] = Regexp.last_match(2)
        when "PD Type" then disk[:interface] = Regexp.last_match(2)
        when "Raw Size" then disk[:size] = Regexp.last_match(2).sub(/\s*\[.*\]$/, "")
        when "Inquiry Data" then disk[:vendor], disk[:model], disk[:serial] = Regexp.last_match(2).split
        end
      elsif array && line =~ /^(\S.*\S)\s*:\s+(\S.*)$/
        case Regexp.last_match(1)
        when "RAID Level" then array[:raid_level] = Regexp.last_match(2).scan(/Primary-(\d+)/).first.first
        when "Size" then array[:size] = Regexp.last_match(2)
        end
      end
    end

    IO.popen(%w(megacli -PDList -aAll -NoLog)).each do |line|
      if line =~ /^Adapter #(\d+)$/
        controller = controllers[Regexp.last_match(1).to_i]
      elsif controller && line =~ /^Enclosure Device ID: \d+$/
        disk = {
          :controller => controller[:id]
        }
      elsif disk && line =~ /^WWN:\s+(\S+)$/
        unless devices[:disks].find { |d| d[:wwn] == Regexp.last_match(1) }
          disk[:id] = devices[:disks].count
          disk[:wwn] = Regexp.last_match(1)

          devices[:disks] << disk
        end
      elsif disk && line =~ /^(\S.*\S)\s*:\s+(\S.*)$/
        case Regexp.last_match(1)
        when "Device Id" then disk[:smart_devlce] = "megaraid,#{Regexp.last_match(2)}"
        when "WWN" then disk[:wwn] = Regexp.last_match(2)
        when "PD Type" then disk[:interface] = Regexp.last_match(2)
        when "Raw Size" then disk[:size] = Regexp.last_match(2).sub(/\s*\[.*\]$/, "")
        when "Inquiry Data" then disk[:vendor], disk[:model], disk[:serial] = Regexp.last_match(2).split
        end
      end
    end

    controllers.each do |controller|
      if device = Dir.glob("/sys/bus/pci/devices/#{controller[:pci_slot]}/host*/target*:2:0/*/scsi_generic/sg*").first
        controller[:device] = "/dev/#{File.basename(device)}"
      end
    end
  end

  collect_data(:default) do
    hardware Mash.new

    hardware[:pci] = pci_devices
    hardware[:network] = network_devices
    hardware[:memory] = memory_devices
    hardware[:disk] = disk_devices
  end
end
